<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.8.17"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Generic Image Library: HoughTransform</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-boost.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div class="boost-header">
      <table border="0" cellpadding="7" cellspacing="0" width="100%" summary="header">
	<tr>
	  <td valign="top" width="300">
            <h3><a href="../index.html"><img alt="Boost GIL" src="../_static/gil.png" border="0"></a></h3>
	  </td>
	  <td ><h1 align="center"><a href="../index.html"></a></h1></td>
	  <td></td>
	</tr>
      </table>
    </div>
    <hr/>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">HoughTransform</div>  </div>
</div><!--header-->
<div class="contents">

<p>A family of shape detectors that are specified by equation.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1gil_1_1hough__parameter.html">hough_parameter&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type to encapsulate Hough transform parameter range.  <a href="structboost_1_1gil_1_1hough__parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2453e44ea538fce4da49b1a09e63299d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structboost_1_1gil_1_1hough__parameter.html">hough_parameter</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___hough_transform.html#ga2453e44ea538fce4da49b1a09e63299d">from_step_count</a> (T start_point, T neighborhood, std::size_t half_step_count)</td></tr>
<tr class="memdesc:ga2453e44ea538fce4da49b1a09e63299d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Hough parameter from value neighborhood and step count.  <a href="group___hough_transform.html#ga2453e44ea538fce4da49b1a09e63299d">More...</a><br /></td></tr>
<tr class="separator:ga2453e44ea538fce4da49b1a09e63299d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga611735fba984082c97a3f0c122b709d7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structboost_1_1gil_1_1hough__parameter.html">hough_parameter</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___hough_transform.html#ga611735fba984082c97a3f0c122b709d7">from_step_size</a> (T start_point, T neighborhood, T step_size)</td></tr>
<tr class="memdesc:ga611735fba984082c97a3f0c122b709d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Hough parameter from value neighborhood and step size.  <a href="group___hough_transform.html#ga611735fba984082c97a3f0c122b709d7">More...</a><br /></td></tr>
<tr class="separator:ga611735fba984082c97a3f0c122b709d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9c1e143c7c33128efa823f6c193663c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___hough_transform.html#gaf9c1e143c7c33128efa823f6c193663c">minimum_angle_step</a> (<a class="el" href="classboost_1_1gil_1_1point.html">point_t</a> dimensions)</td></tr>
<tr class="memdesc:gaf9c1e143c7c33128efa823f6c193663c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate minimum angle which would be observable if walked on a circle.  <a href="group___hough_transform.html#gaf9c1e143c7c33128efa823f6c193663c">More...</a><br /></td></tr>
<tr class="separator:gaf9c1e143c7c33128efa823f6c193663c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf54301aeb8d2a2811db3e1b454bdd99e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1gil_1_1hough__parameter.html">hough_parameter</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___hough_transform.html#gaf54301aeb8d2a2811db3e1b454bdd99e">make_theta_parameter</a> (double approx_angle, double neighborhood, <a class="el" href="classboost_1_1gil_1_1point.html">point_t</a> dimensions)</td></tr>
<tr class="memdesc:gaf54301aeb8d2a2811db3e1b454bdd99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Hough transform parameter with optimal angle step.  <a href="group___hough_transform.html#gaf54301aeb8d2a2811db3e1b454bdd99e">More...</a><br /></td></tr>
<tr class="separator:gaf54301aeb8d2a2811db3e1b454bdd99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2573aec8de0799351116129f7bc6d6a0"><td class="memTemplParams" colspan="2">template&lt;typename InputView , typename OutputView &gt; </td></tr>
<tr class="memitem:ga2573aec8de0799351116129f7bc6d6a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___hough_transform.html#ga2573aec8de0799351116129f7bc6d6a0">hough_line_transform</a> (const InputView &amp;input_view, const OutputView &amp;accumulator_array, const <a class="el" href="structboost_1_1gil_1_1hough__parameter.html">hough_parameter</a>&lt; double &gt; &amp;theta, const <a class="el" href="structboost_1_1gil_1_1hough__parameter.html">hough_parameter</a>&lt; std::ptrdiff_t &gt; &amp;radius)</td></tr>
<tr class="memdesc:ga2573aec8de0799351116129f7bc6d6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vote for best fit of a line in parameter space.  <a href="group___hough_transform.html#ga2573aec8de0799351116129f7bc6d6a0">More...</a><br /></td></tr>
<tr class="separator:ga2573aec8de0799351116129f7bc6d6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b86b273ee7d26cc61f633c24164c70f"><td class="memTemplParams" colspan="2">template&lt;typename ImageView , typename ForwardIterator , typename Rasterizer &gt; </td></tr>
<tr class="memitem:ga5b86b273ee7d26cc61f633c24164c70f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___hough_transform.html#ga5b86b273ee7d26cc61f633c24164c70f">hough_circle_transform_brute</a> (const ImageView &amp;input, const <a class="el" href="structboost_1_1gil_1_1hough__parameter.html">hough_parameter</a>&lt; std::ptrdiff_t &gt; radius_parameter, const <a class="el" href="structboost_1_1gil_1_1hough__parameter.html">hough_parameter</a>&lt; std::ptrdiff_t &gt; x_parameter, const <a class="el" href="structboost_1_1gil_1_1hough__parameter.html">hough_parameter</a>&lt; std::ptrdiff_t &gt; &amp;y_parameter, ForwardIterator d_first, Rasterizer rasterizer)</td></tr>
<tr class="memdesc:ga5b86b273ee7d26cc61f633c24164c70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vote for best fit of a circle in parameter space according to rasterizer.  <a href="group___hough_transform.html#ga5b86b273ee7d26cc61f633c24164c70f">More...</a><br /></td></tr>
<tr class="separator:ga5b86b273ee7d26cc61f633c24164c70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A family of shape detectors that are specified by equation. </p>
<p>Hough transform is a method of mapping (voting) an object which can be described by equation to single point in accumulator array (also called parameter space). Each set pixel in edge map votes for every shape it can be part of. Circle and ellipse transforms are very costly to brute force, while non-brute-forcing algorithms tend to gamble on probabilities. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2453e44ea538fce4da49b1a09e63299d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2453e44ea538fce4da49b1a09e63299d">&#9670;&nbsp;</a></span>from_step_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structboost_1_1gil_1_1hough__parameter.html">hough_parameter</a>&lt;T&gt; from_step_count </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>neighborhood</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>half_step_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create Hough parameter from value neighborhood and step count. </p>
<p>This function will take start_point as middle point, and in both directions will try to walk half_step_count times until distance of neighborhood is reached </p>

</div>
</div>
<a id="ga611735fba984082c97a3f0c122b709d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga611735fba984082c97a3f0c122b709d7">&#9670;&nbsp;</a></span>from_step_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structboost_1_1gil_1_1hough__parameter.html">hough_parameter</a>&lt;T&gt; from_step_size </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>neighborhood</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>step_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create Hough parameter from value neighborhood and step size. </p>
<p>This function will take start_point as middle point, and in both directions will try to walk step_size at a time until distance of neighborhood is reached </p>

</div>
</div>
<a id="ga5b86b273ee7d26cc61f633c24164c70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b86b273ee7d26cc61f633c24164c70f">&#9670;&nbsp;</a></span>hough_circle_transform_brute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boost::gil::hough_circle_transform_brute </td>
          <td>(</td>
          <td class="paramtype">const ImageView &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structboost_1_1gil_1_1hough__parameter.html">hough_parameter</a>&lt; std::ptrdiff_t &gt;&#160;</td>
          <td class="paramname"><em>radius_parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structboost_1_1gil_1_1hough__parameter.html">hough_parameter</a>&lt; std::ptrdiff_t &gt;&#160;</td>
          <td class="paramname"><em>x_parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structboost_1_1gil_1_1hough__parameter.html">hough_parameter</a>&lt; std::ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>d_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rasterizer&#160;</td>
          <td class="paramname"><em>rasterizer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vote for best fit of a circle in parameter space according to rasterizer. </p>
<p>The input must be an edge map with grayscale pixels. Be aware of overflow inside accumulator array. Rasterizer is used to rasterize a circle for voting. The circle then is translated for every origin (x, y) in x y parameter space. For available circle rasterizers, please look at rasterization/circle.hpp </p>

</div>
</div>
<a id="ga2573aec8de0799351116129f7bc6d6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2573aec8de0799351116129f7bc6d6a0">&#9670;&nbsp;</a></span>hough_line_transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boost::gil::hough_line_transform </td>
          <td>(</td>
          <td class="paramtype">const InputView &amp;&#160;</td>
          <td class="paramname"><em>input_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OutputView &amp;&#160;</td>
          <td class="paramname"><em>accumulator_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structboost_1_1gil_1_1hough__parameter.html">hough_parameter</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structboost_1_1gil_1_1hough__parameter.html">hough_parameter</a>&lt; std::ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vote for best fit of a line in parameter space. </p>
<p>The input must be an edge map with grayscale pixels. Be aware of overflow inside accumulator array. The theta parameter is best computed through factory function provided in <a class="el" href="hough__parameter_8hpp_source.html">hough_parameter.hpp</a> </p>

</div>
</div>
<a id="gaf54301aeb8d2a2811db3e1b454bdd99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf54301aeb8d2a2811db3e1b454bdd99e">&#9670;&nbsp;</a></span>make_theta_parameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structboost_1_1gil_1_1hough__parameter.html">hough_parameter</a>&lt;double&gt; boost::gil::make_theta_parameter </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>approx_angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>neighborhood</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1gil_1_1point.html">point_t</a>&#160;</td>
          <td class="paramname"><em>dimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a Hough transform parameter with optimal angle step. </p>
<p>Due to computational intensity and noise sensitivity of Hough transform, having any candidates missed or computed again is problematic. This function will properly encapsulate optimal value range around approx_angle with amplitude of neighborhood in each direction. WARNING: do keep in mind IEEE 754 quirks, e.g. no-associativity, no-commutativity and precision. Do not expect expressions that are mathematically the same to produce the same values </p>

</div>
</div>
<a id="gaf9c1e143c7c33128efa823f6c193663c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9c1e143c7c33128efa823f6c193663c">&#9670;&nbsp;</a></span>minimum_angle_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double boost::gil::minimum_angle_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1gil_1_1point.html">point_t</a>&#160;</td>
          <td class="paramname"><em>dimensions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate minimum angle which would be observable if walked on a circle. </p>
<p>When drawing a circle or moving around a point in circular motion, it is important to not do too many steps, but also to not have disconnected trajectory. This function will calculate the minimum angle that is observable when walking on a circle or tilting a line. WARNING: do keep in mind IEEE 754 quirks, e.g. no-associativity, no-commutativity and precision. Do not expect expressions that are mathematically the same to produce the same values </p>

</div>
</div>
</div><!-- contents -->
     <!-- HTML footer for doxygen 1.8.13-->
     <!-- start footer part -->
     <hr class="footer"/>
     <address class="footer">
      <small>
        Generated by &#160;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.17
      </small>
    </address>
  </body>
</html>
